/*global define*/define([    'scalejs!core',    'knockout',    'knockout.mapping',    'jQuery',    'kendo.grid'], function (    core,    ko,    mapping,    $) {    'use strict';    var unwrap = ko.utils.unwrapObservable,        isObservable = ko.isObservable,        merge = core.object.merge,        has = core.object.has,        is = core.type.is;    /*jslint unparam: true*/    function init(        element,        valueAccessor,        allBindingsAccessor    ) {        var b = allBindingsAccessor(),            options = b.kendoGrid,            itemsSource = options.itemsSource,            editItem = options.editItem,            selectedItem = options.selectedItem,            toJS = mapping.toJS,            grid,            computed,            dataBinding,            isInitialized = false,            toEnumerable = core.linq.enumerable.from,            batch = options.batch || false;        function onDataSourceChange(e) {            if (e.action === 'itemchange') {                var item = e.items[0],                    value = item[e.field],                    viewmodelProperty = item.viewmodel[e.field];                viewmodelProperty(value);            }        }        options.dataSource = {            transport: {                read: function(options) {                    console.log('--->read');                    console.log(options);                    var source = unwrap(itemsSource),                        total = source.length,                        items = toEnumerable(source);                    if (has(options, 'data', 'sort') && options.data.sort.length > 0) {                        // assume single column sort for now                        var sort = options.data.sort[0],                            comparer = function(x) {                                return unwrap(x[sort.field]);                            };                        if (sort.dir === 'asc') {                            items = items.orderBy(comparer);                        } else {                            items = items.orderByDescending(comparer);                        }                    }                    if (has(options, 'data', 'filter', 'filters') && options.data.filter.filters.length > 0) {                        // TODO: multiple filters                        var filter = options.data.filter.filters[0];                        items = items.where(function(x) {                            var val = unwrap(x[filter.field]);                            switch (filter.operator) {                                case 'lt':                                    return val < filter.value;                            }                            return true;                        }).memoizeAll();                        total = items.count();                    }                    if (has(options, 'data', 'group') && options.data.group.length > 0) {                        var grouping = options.data.group[0];                        items = items                            .orderBy(function(x) {                                return unwrap(x[grouping.field]);                            })                            .skip(options.data.skip)                            .take(options.data.take)                            .groupBy(function(x) {                                return unwrap(x[grouping.field]);                            })                            .select(function(g) {                                var aggregates = {};                                aggregates[grouping.field] = { count: 10 };                                return {                                    aggregates: aggregates,                                    field: grouping.field,                                    value: g.Key(),                                    items: g.ToArray()                                };                            })                            .toArray();                        items = {                            groups: items                                                        };                    }                     if (has(items, 'toArray')) {                        //items = items.zip(items, function (i1, i2) { i1.viewmodel = i2; return i1 });                        items = items.skip(options.data.skip).take(options.data.take).toArray();                    }                    var data = toJS(items);                    data = toEnumerable(data).zip(toEnumerable(items), function (d,i) {                         return merge(d, {viewmodel: i});                    }).toArray();                    options.success({                        items: data,                         total: total                    });                },            },            schema: {                data: function(response) {                    return response.items;                },                total: function(response) {                    return response.total;                },                groups: 'groups'            },            serverPaging: true,            pageSize: options.pageSize || 50,            //batch: batch,            change: onDataSourceChange,            serverAggregates: true,            serverFiltering: true,            serverGrouping: false,            serverSorting: true        };        if (has(options, 'toolbar')) {
            var toolbarEl = $('#' + options.toolbar)[0];
            if (has(toolbarEl)) {
                options.toolbar = toolbarHtml;
            }
        }
        /*        options.dataBound = function (e) {            if (!has(grid)) return;            console.log('--->data bound');            console.log(e);            var gridData = grid.dataSource.data();            dataBinding = toEnumerable(itemsView)                .zip(toEnumerable(gridData), 'd,m => {data: d, model: m}')                .toObject("$.model.uid", "$");            //console.log(gridData);            //console.log(items);        }*/                delete options.itemsSource;        delete options.pageSize;        grid = $(element).kendoGrid(options).data("kendoGrid");        function row(item, forceVisible) {            var db = toEnumerable(dataBinding).firstOrDefault(null, function(db) {                return db.Value.data === edit;            });            if (has(db, 'Key')) {                var selector = 'tr[data-uid="' + db.Key + '"]',                    gridRow;                if (forceVisible) {                    // TODO: find item's page, don't assume it's the last one                    //grid.dataSource.page(grid.dataSource.totalPages());                    gridRow = grid.tbody.find(selector);                    //grid.editRow(gridRow);                } else {                    gridRow = grid.tbody.find(selector);                }                return gridRow;            }                        return null;        }                ko.computed({            read: function() {                var selected = unwrap(selectedItem);                var gridRow = grid.select(selected);                grid.select(gridRow);            },            disposeWhenNodeIsRemoved: element        });                ko.computed({            read: function() {                var edit = unwrap(editItem);                setTimeout(function() {                    var db = toEnumerable(dataBinding).firstOrDefault(null, function(db) {                        return db.Value.data === edit;                    });                    if (has(db, 'Key')) {                        //grid.dataSource.page(grid.dataSource.totalPages());                        var selector = 'tr[data-uid="' + db.Key + '"]';                        var row = grid.tbody.find(selector);                        grid.editRow(row);                    }                }, 0);                //grid.editRow();            },            disposeWhenNodeIsRemoved: element        });                computed = ko.computed({            read: function () {                items = unwrap(itemsSource);                setTimeout(function () {                    grid.dataSource.read();                }, 0);            },            disposeWhenNodeIsRemoved: element        });        if (!isObservable(itemsSource)) {            computed.dispose();        }    }    /*jslint unparam: false*/    return {        init: init    };});